<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pipipapi</title>
  
  
  <link href="https://wangyuhang-cmd.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangyuhang-cmd.github.io/"/>
  <updated>2021-08-10T07:55:30.613Z</updated>
  <id>https://wangyuhang-cmd.github.io/</id>
  
  <author>
    <name>Pipipapi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最小生成树</title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2021-08-10T07:53:16.000Z</published>
    <updated>2021-08-10T07:55:30.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h6 id="最小生成树理论基础："><a href="#最小生成树理论基础：" class="headerlink" title="最小生成树理论基础："></a>最小生成树理论基础：</h6><p>1.任意一颗最小生成树一定<strong>可以</strong>包含无向图中权值最小的边</p><p>2.给定一张无向图G=(V, E)，n=|M|, m=|E|。从E中选出k &lt; n- 1条边构成G的一个生成森林。若再从剩余的m-k条边中选n- 1 - k条边添加到生成森林中，使其成为G的生成树，并且选出的边的权值之和最小。则该生成树一定可以包含m - k条边中连接生成森林的两个不连通节点的权值最小的边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">最小生成树&#123;</span><br><span class="line">Prim algorithm&#123;</span><br><span class="line"><span class="number">1.</span>朴素版<span class="function">Prim <span class="title">O</span><span class="params">(O^<span class="number">2</span>)</span> 稠密图</span>&#123;</span><br><span class="line">将所有点初始化为正无穷</span><br><span class="line">迭代n次</span><br><span class="line">找到集合外最近的点</span><br><span class="line">判断这个点是不是连通的</span><br><span class="line">如果不是第一条边就进行累加</span><br><span class="line">用这个点更新集合外的点到集合的距离(不更新累加距离，只更新最短距离)</span><br><span class="line">标记这个集合并加入集合</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>堆优化<span class="function">Prim <span class="title">O</span><span class="params">(mlogn)</span> 稀疏图</span>&#123;<span class="comment">//一般不用，用克鲁斯卡尔代替</span></span><br><span class="line">这里就先不写了...</span><br><span class="line">&#125;</span><br><span class="line">&#125;Kruskal algorithm&#123; <span class="built_in">O</span>(mlogm) 稀疏图</span><br><span class="line"><span class="number">1.</span>将所有边按权重从小到大排序 <span class="built_in">O</span>(mlogm)</span><br><span class="line"><span class="number">2.</span>初始化并查集</span><br><span class="line"><span class="number">3.</span>从小到大枚举每条边(a-b权重c),若a,b不连通，将a,b加入集合中</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二分图&#123;<span class="comment">//一个图是二分图当且仅当图中不含奇数环</span></span><br><span class="line"><span class="number">1.</span>染色法&#123; <span class="built_in">O</span>(n+m)</span><br><span class="line"><span class="number">1.</span>建邻接表</span><br><span class="line"><span class="number">2.f</span><span class="keyword">or</span>(<span class="number">1</span>~n)</span><br><span class="line"><span class="keyword">if</span>(i未染色）</span><br><span class="line"><span class="built_in">dfs</span>(i)</span><br><span class="line">需要标记每个点是否被染色</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>匈牙利算法&#123; <span class="built_in">O</span>(nm),实际运行时间远小于<span class="built_in">O</span>(nm)</span><br><span class="line">最快时间内得出二分图成功匹配的最大的数量（成功匹配：没有两条边共用一个点）</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">最大流算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树-1"><a href="#最小生成树-1" class="headerlink" title="最小生成树"></a>最小生成树</h2><h4 id="Prim-algorithm"><a href="#Prim-algorithm" class="headerlink" title="Prim algorithm"></a>Prim algorithm</h4><p>prim算法是从一个点开始扩展，逐渐得到一棵树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 510</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[MAXN][MAXN],dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> st[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//n次迭代</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dis[t]&gt;dis[j]))</span><br><span class="line">                t=j;</span><br><span class="line">               </span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;dis[t]==INF) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>) res+=dis[t];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">            dis[j]=<span class="built_in">min</span>(dis[j],g[t][j]);</span><br><span class="line">            </span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>结合了并查集的思想，将所有边排序后开始选择，在图中主键连通的过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Kruskal algorithm&#123; <span class="built_in">O</span>(mlogm) 稀疏图</span><br><span class="line"><span class="number">1.</span>将所有边按权重从小到大排序 <span class="built_in">O</span>(mlogm)</span><br><span class="line"><span class="number">2.</span>初始化并查集</span><br><span class="line"><span class="number">3.</span>从小到大枚举每条边(a-b权重c),若a,b不连通，将a,b加入集合中</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edges</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edges W) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edges[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==fa[x]?fa[x]:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;edges[i].a,&amp;edges[i].b,&amp;edges[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges+<span class="number">1</span>,edges+<span class="number">1</span>+m); <span class="comment">//第一步排序</span></span><br><span class="line">    <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a=edges[i].a,b=edges[i].b,w=edges[i].w;</span><br><span class="line">        </span><br><span class="line">        a=<span class="built_in">find</span>(a),b=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">            fa[a]=b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最小生成树&quot;&gt;&lt;a href=&quot;#最小生成树&quot; class=&quot;headerlink&quot; title=&quot;最小生成树&quot;&gt;&lt;/a&gt;最小生成树&lt;/h1&gt;&lt;h6 id=&quot;最小生成树理论基础：&quot;&gt;&lt;a href=&quot;#最小生成树理论基础：&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="图论" scheme="https://wangyuhang-cmd.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>图论题技巧整理</title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/08/%E5%9B%BE%E8%AE%BA%E9%A2%98%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/08/%E5%9B%BE%E8%AE%BA%E9%A2%98%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/</id>
    <published>2021-08-08T11:38:08.000Z</published>
    <updated>2021-08-08T11:48:26.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图论题技巧整理"><a class="markdownIt-Anchor" href="#图论题技巧整理"></a> 图论题技巧整理</h2><h5 id="最短路径模型"><a class="markdownIt-Anchor" href="#最短路径模型"></a> 最短路径模型</h5><p>1.建立虚拟源点</p><ul><li>虚拟远点的建立可以将点权转化为边权</li><li>对于多个起点，一个终点的情况，也可以建立虚拟源点。从源点向每个起点出发连接一条长度为0的边。这样就可以转化为从虚拟源点出发，能到达中点的最短路径</li></ul><p>2.记录路径（将dist[] 数组开至二维）</p><ul><li>对于按照某一顺序访问多个节点的题目可以先遍历记录路径，再使用DFS()根据全排列求解</li></ul><p>3.将边权进行0，1转换</p><ul><li>对于求第k+1大的路径或者求最大的路径使得某某条件最小时，可以配合二分，将所有边权分类为1和0来进行求解(分类)</li></ul><p>4.对于不同连通块，内部只有正权边，外部由负权边构成的图</p><ul><li>按照拓扑序做堆优化的Dijkstra算法。由于按照拓扑序列，因此保证了到每一点的距离都为最小</li></ul><p>5.考虑建立反向边</p><ul><li>当起点有多个而只有一个确定的终点时，应当考虑建立反向边</li></ul><p>6.正反各进行遍历</p><ul><li>对于在途中买卖一次商品的题目，考虑正反都进行遍历，然后最后使用DP的思想来划分集合，然后求解</li></ul><p>7.拆点</p><p>将dist数组扩展至二维，来存储点的不同性质（类似于DP）。例如寻找最短路径和次短路径的时候可以选择拆点</p><p>8.有负权边，求在最短路径条数：</p><ul><li><p>先使用SPFA求出所有最短路径，枚举所有t-&gt;j的边w[i]，判断每个边是否满足:</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mo>=</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dist[j]==dist[t]+w[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span></p></li><li></li></ul><p>9.求最短路径条数：</p><ul><li>使用Dijkstra算法或者BFS能够保证拓扑序。在更新最短距离的时候顺便记录一下条数即可</li></ul><p>10.恰好经过k条路的最短路径</p><ul><li>1.快速幂+类Floyd算法</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">[</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mo stretchy="false">[</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">[</mo><mi>a</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mo stretchy="false">[</mo><mi>b</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d[a+b,i,j]=min(d[a+b,i,j],d[a,i,k]+d[b,k,j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><ul><li>2.bellman_ford算法</li></ul><h5 id="最小生成树模型"><a class="markdownIt-Anchor" href="#最小生成树模型"></a> 最小生成树模型</h5><p>1.建立超级源点</p><p>便于将点权转化为边权</p><p>2.次小生成树</p><p>定义：给一个带权图，把图中所有生成树按权值从小到大排序，第二小的成为次小生成树</p><ul><li>有两种定义方式，一种是按照排列定义的第二小，因此可能数值与最小生成树一样。第二种是严格次小生成树，即严格小于最小生成树</li></ul><p><strong>方法1</strong>：先求最小生成树，再枚举删除最小生成树的边求解,时间复杂度为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo>+</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mlogm+nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p><p>劣势：不容易求严格最小生成树</p><p><em>证明</em> 设T为图G的一颗生成树，对于非树边a和非树边b，插入边a，并删除边b的操作记为(+a,-b)</p><p>如果T+a-b之后仍然是一颗生成树，称(+a,-b)是T的一个可行交换</p><p>称由T进行依次可行变换所得到的新的生成树集合为T的邻集，次小生成树一定在最小生成树的邻集当中。</p><p><strong>方法2</strong>：先求最小生成树，然后依次枚举非树边，然后将改边加入树中，同时从树中去掉一条边，使得最终的图仍是一棵树</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n^2+mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p><p>可用树上倍增LCA优化至</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Q(m+mlogn+mlogm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></span></p><h5 id="基于spfa求负环"><a class="markdownIt-Anchor" href="#基于spfa求负环"></a> 基于SPFA求负环</h5><p>1.统计每个点入队的次数，如果某个点入队n次说明存在负环</p><p>2.统计每个点的最短路中所包含的边数，如果某个点的最短路所包含的边数大于等于n，则也说明存在负环</p><p>但是由于SPFA判断负环的时间复杂度比较高，约O(nm)，因此有一种较为取巧的方式：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">当</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">被</mi><mi mathvariant="normal">更</mi><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">迭</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">超</mi><mi mathvariant="normal">过</mi><mn>2</mn><mi>n</mi><mo stretchy="false">(</mo><mi mathvariant="normal">尽</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">开</mi><mi mathvariant="normal">大</mi><mo stretchy="false">)</mo><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">就</mi><mi mathvariant="normal">认</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">概</mi><mi mathvariant="normal">率</mi><mi mathvariant="normal">图</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">负</mi><mi mathvariant="normal">环</mi></mrow><annotation encoding="application/x-tex">当所有点的被更新的迭代次数超过2n(尽量开大)时，我们就认为大概率图中有负环</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">更</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">迭</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">超</span><span class="mord cjk_fallback">过</span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord cjk_fallback">尽</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">大</span><span class="mclose">)</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">认</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">概</span><span class="mord cjk_fallback">率</span><span class="mord cjk_fallback">图</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">负</span><span class="mord cjk_fallback">环</span></span></span></span></span></p><h5 id="01分数规划"><a class="markdownIt-Anchor" href="#01分数规划"></a> 01分数规划</h5><p>图论问题形如求</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Σ</mi><msub><mi>f</mi><mi>i</mi></msub></mrow><mrow><mi mathvariant="normal">Σ</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></mfrac><mi mathvariant="normal">的</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">值</mi></mrow><annotation encoding="application/x-tex">\frac{\Sigma{f_i}}{\Sigma{t_i}}的最大值</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Σ</span><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Σ</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">值</span></span></span></span></span></p><p>为01分数规划，一般思路：<strong>二分</strong>比值,然后判断图中是否存在正环</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图论题技巧整理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图论题技巧整理&quot;&gt;&lt;/a&gt; 图论题技巧整理&lt;/h2&gt;
&lt;h5 id=&quot;最短路径模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#最短路径模型&quot;&gt;</summary>
      
    
    
    
    
    <category term="OI" scheme="https://wangyuhang-cmd.github.io/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>模拟退火模板_c++</title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/08/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E6%A8%A1%E6%9D%BF-c/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/08/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E6%A8%A1%E6%9D%BF-c/</id>
    <published>2021-08-08T11:37:57.000Z</published>
    <updated>2021-08-08T11:44:19.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模拟退火算法"><a class="markdownIt-Anchor" href="#模拟退火算法"></a> 模拟退火算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> T=<span class="number">100</span>; <span class="comment">//初始温度</span></span><br><span class="line"><span class="keyword">double</span> delta = <span class="number">0.98</span>; <span class="comment">//降温系数</span></span><br><span class="line"><span class="keyword">double</span> x=<span class="number">50.0</span>;  <span class="comment">//x的初始温度</span></span><br><span class="line"><span class="keyword">double</span> now=<span class="built_in">func</span>(x);  <span class="comment">//计算初始函数值</span></span><br><span class="line"><span class="keyword">double</span> ans=now;  <span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">while</span>(T&gt;eps)&#123;     <span class="comment">//eps是终止温度</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> newx = x+f[<span class="built_in">rand</span>()%<span class="number">2</span>]*T; <span class="comment">//按概率改变x，随T的降温而减少</span></span><br><span class="line"><span class="keyword">if</span>(newx &gt;= <span class="number">0</span> &amp;&amp; newx&lt;=<span class="number">100</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> next = <span class="built_in">func</span>(newx);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,next);</span><br><span class="line"><span class="keyword">if</span>(now-next&gt;eps)&#123;x=newx;now=next;&#125;</span><br><span class="line">&#125;</span><br><span class="line">T*=delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;模拟退火算法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#模拟退火算法&quot;&gt;&lt;/a&gt; 模拟退火算法&lt;/h3&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    
    <category term="OI" scheme="https://wangyuhang-cmd.github.io/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>单调队列优化动态规划</title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/08/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%B8%8E%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/08/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%B8%8E%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-08-08T11:37:31.000Z</published>
    <updated>2021-08-08T11:43:20.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单调队列优化dp"><a class="markdownIt-Anchor" href="#单调队列优化dp"></a> 单调队列优化DP</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">划定区间取值问题</span><br><span class="line">对于长度为l的区间，每s长度至少有一个数被取，使用动态规划</span><br><span class="line"><span class="built_in">f</span>(i)表示选第i个数的最小方案</span><br><span class="line">集合划分：可以取i-s+<span class="number">1</span>到i<span class="number">-1</span>的各种方式</span><br><span class="line">因此f[i]=w[i]+<span class="built_in">min</span>(f[i-m+<span class="number">1</span>],....,f[i<span class="number">-1</span>])</span><br><span class="line">对于后面这一段<span class="built_in">min</span>(f[i-m+<span class="number">1</span>~i<span class="number">-1</span>])可以使用单调队列优化。</span><br></pre></td></tr></table></figure><hr><h1 id="凸包优化dp斜率优化"><a class="markdownIt-Anchor" href="#凸包优化dp斜率优化"></a> 凸包优化DP（斜率优化）</h1><p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \ at position 64: …-C_j) \}  \ \ \̲̲'>由状态转移方程：\ \ f[i]=min\{ f[j]+T_{i}(C_i-C_j)+S(C_n-C_j) \}  \ \ \</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">其</mi><mi mathvariant="normal">中</mi><mi>j</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1...</mn><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">其中j=0,1...i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">整</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">以</mi><msub><mi>C</mi><mi>j</mi></msub><mi mathvariant="normal">为</mi><mi mathvariant="normal">自</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">，</mi><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mi mathvariant="normal">为</mi><mi mathvariant="normal">因</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">函</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">我们可以将其整理为以C_j为自变量，f[j]为因变量的一次函数形式：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">以</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">自</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">：</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>S</mi><mo>+</mo><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>C</mi><mi>j</mi></msub><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>−</mo><msub><mi>T</mi><mi>i</mi></msub><msub><mi>C</mi><mi>i</mi></msub><mo>−</mo><mi>S</mi><msub><mi>C</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">f(j)=(S+T_i)C_j+f(i)-T_iC_i-SC_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>因为要最小化f(i),对于本题来说，就是找截距最小值，在图中我们可以发现只需要维护图中的凸包的下边界：<img src="C:%5CUsers%5CHenry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210726154444502.png" alt="image-20210726154444502" /></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">凸</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">界</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">义</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">任</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">两</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">连</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">连</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">都</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">凸</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">边</mi><mi mathvariant="normal">界</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">上</mi></mrow><annotation encoding="application/x-tex">凸包下边界的定义：任意两点连线，在连线上方的点都在凸包的下边界以上</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">凸</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">界</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">义</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">两</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">连</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">都</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">凸</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">界</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">上</span></span></span></span></span></p><p>但是只维护凸包的下边界最坏会出现O(n)的情况，因此仍然需要挖掘其他信息：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.</mn><mi mathvariant="normal">某</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">被</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">斜</mi><mi mathvariant="normal">率</mi><mi mathvariant="normal">大</mi><mi mathvariant="normal">于</mi><mi>k</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">第</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">起</mi><mi mathvariant="normal">点</mi></mrow><annotation encoding="application/x-tex">1.某点被取当为斜率大于k的第一个点的起点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord cjk_fallback">某</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">斜</span><span class="mord cjk_fallback">率</span><span class="mord cjk_fallback">大</span><span class="mord cjk_fallback">于</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">起</span><span class="mord cjk_fallback">点</span></span></span></span></span></p><p><img src="C:%5CUsers%5CHenry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210726154551944.png" alt="image-20210726154551944" /></p><p>总结：如何在维护凸包中找到截距最小的点：</p><p>相当于在于一个单调的队列中，找到第一个大于某一个数的点。因此普遍做法是采用二分法。</p><p>其他特殊性质：</p><p>1.斜率单调递增，新加的点的横坐标也单调递增(k1&lt;k2&lt;k3)</p><p>​在查询的时候可以将队头小于当前斜率的点全部删除(删除所有小于k的点)</p><p>​在插入的时候，把队尾<strong>所有</strong>不满足要求的点全部删除（即不在凸包上）</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1.</mn><mi mathvariant="normal">若</mi><mtext>   </mtext><mfrac><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>−</mo><msub><mi>f</mi><mn>1</mn></msub></mrow><mrow><msub><mi>C</mi><mn>2</mn></msub><mo>−</mo><msub><mi>C</mi><mn>1</mn></msub></mrow></mfrac><mo>≤</mo><mi>s</mi><mi>u</mi><mi>m</mi><msub><mi>T</mi><mi>i</mi></msub><mo>+</mo><mi>S</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">则</mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">队</mi><mi mathvariant="normal">头</mi></mrow><annotation encoding="application/x-tex">1. 若\ \ \  \frac{f_2-f_1}{C_2-C_1} \le sumT_i+S是则删除队头</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord cjk_fallback">若</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">删</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">队</span><span class="mord cjk_fallback">头</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2.</mn><mi mathvariant="normal">若</mi><mtext>  </mtext><mfrac><mrow><msub><mi>f</mi><mrow><mi>t</mi><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>f</mi><mrow><mi>t</mi><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><mrow><msub><mi>C</mi><mrow><mi>t</mi><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>C</mi><mrow><mi>t</mi><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mfrac><mo>≥</mo><mfrac><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>−</mo><msub><mi>f</mi><mrow><mi>t</mi><mi>t</mi></mrow></msub></mrow><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>−</mo><msub><mi>C</mi><mrow><mi>t</mi><mi>t</mi></mrow></msub></mrow></mfrac><mi mathvariant="normal">则</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">队</mi><mi mathvariant="normal">尾</mi><mi mathvariant="normal">元</mi><mi mathvariant="normal">素</mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">去</mi></mrow><annotation encoding="application/x-tex">2.若\ \  \frac{f_{tt}-f_{tt-1}}{C_{tt}-C_{tt-1}} \ge \frac{f_i-f_{tt}}{C_i-C_{tt}}则将队尾元素删去</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.265771em;vertical-align:-0.894331em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord cjk_fallback">若</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.894331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">队</span><span class="mord cjk_fallback">尾</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">素</span><span class="mord cjk_fallback">删</span><span class="mord cjk_fallback">去</span></span></span></span></span></p><p>例题：Acwing 301</p><h3 id="更一般的情况t0时"><a class="markdownIt-Anchor" href="#更一般的情况t0时"></a> 更一般的情况，T&lt;0时：</h3><p>​此时k无法保证单调性，但新加的点横坐标一定单调递增。因此只能查询，不能删去斜率小于当前点的点。查询的时候只能二分；</p><p>​队尾仍然删除所有队尾不在凸包上的点</p><p>如果T&gt;0,C&lt;0 可以使用反函数，交换x,y</p><h3 id="最一般的情况"><a class="markdownIt-Anchor" href="#最一般的情况"></a> 最一般的情况：</h3><p>考虑C可能小于0且T也可能小于0</p><p>​队头处理还是二分。队尾的动态维护有序序列则需要平衡树来做了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单调队列优化dp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单调队列优化dp&quot;&gt;&lt;/a&gt; 单调队列优化DP&lt;/h1&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    
    <category term="OI" scheme="https://wangyuhang-cmd.github.io/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-08-08T11:37:15.000Z</published>
    <updated>2021-08-08T11:44:05.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h1><hr><h2 id="背包模型"><a class="markdownIt-Anchor" href="#背包模型"></a> 背包模型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Dp&#123;</span><br><span class="line">    状态表示&#123;</span><br><span class="line">        集合&#123;</span><br><span class="line">            表示的是所有选法</span><br><span class="line">                </span><br><span class="line">            满足条件条件&#123;</span><br><span class="line">                <span class="number">1.</span>只从前i个物品中选</span><br><span class="line">                </span><br><span class="line">                <span class="number">2.</span>总体积&lt;=j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        属性  Min,Max,数量</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    状态计算 集合划分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="01背包问题"><a class="markdownIt-Anchor" href="#01背包问题"></a> 01背包问题</h4><p>n个物品和一个容量为v的背包，每一个物品体积vi,价值wi,每件物品只能用一次.</p><p>求背包能装的下的情况下能装下的最大价值为多少,我们考虑有递推式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i])</span><br></pre></td></tr></table></figure><p>再空间优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br></pre></td></tr></table></figure><hr><h4 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题"></a> 完全背包问题</h4><p>每件物品可以用无限次，只要装得下。</p><p>状态转移方程代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-k*v[i]]+k*w[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们考虑对其做优化，参考01背包，先对空间做优化，然后我们可以推导出</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>2</mn><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[j]=max(dp[j],dp[j-v[i]]+w[i],dp[j-2v[i]]+2w[i]...)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mclose">)</span></span></span></span></span></p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>2</mn><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[j-v[i]]=max(dp[j-v[i]],dp[j-2v[i]]+w[i]...)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mclose">)</span></span></span></span></span></p><p>对比上两个方程我们可以推导出：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[j]=max(dp[j],dp[j-v[i]]+w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=v[i];j&lt;=m;j++)</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i])</span><br></pre></td></tr></table></figure><hr><h4 id="多重背包问-题"><a class="markdownIt-Anchor" href="#多重背包问-题"></a> 多重背包问 题</h4><p>每件物品的数量有限制，各为 Si：</p><h5 id="1朴素版"><a class="markdownIt-Anchor" href="#1朴素版"></a> 1.朴素版</h5><p>​核心思想：二进制优化；</p><p>​我们将s[i]拆分成二进制表示的1，2…2<sup>k，其中2</sup>k&lt;=s[i]/2</p><p>​然后转化成01背包来做</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>⋅</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>⋅</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i-1][j-k\cdot v[i]]+k\cdot w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>​其中k=0,1,2…s[i]</p><p>我们将dp数组的行进行压缩可以得到：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mi>k</mi><mo>⋅</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>k</mi><mo>⋅</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[j]=max(dp[j],dp[j-k\cdot v[i]]+k\cdot w[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>实现代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-k*v[i]]+k*w[i])</span><br></pre></td></tr></table></figure><h5 id="2二进制优化版"><a class="markdownIt-Anchor" href="#2二进制优化版"></a> 2.二进制优化版</h5><p>我们可以将每个物品的数量s做二进制优化，即将每一个s拆分成1,2,4…2<sup>k,s+1-2</sup>(k+1)。这样我们可以使用这些数表示任意1-s区间内的每一个数，并且时间复杂度也可以从原来的O(nms)优化到O(nmlogs)。然后我们呢对于拆分出来的物品用01背包的思路来做即可；</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;  <span class="comment">//二进制优化</span></span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c&gt;=u)&#123;</span><br><span class="line">            v[++cnt]=a*u;</span><br><span class="line">            w[cnt]=b*u;</span><br><span class="line">            c-=u;</span><br><span class="line">            u*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            v[++cnt]=a*c;</span><br><span class="line">            w[cnt]=b*c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n=cnt;</span><br></pre></td></tr></table></figure><hr><h4 id="分组背包问题"><a class="markdownIt-Anchor" href="#分组背包问题"></a> 分组背包问题</h4><p>物品有n组，每一组有若干个，每一组最多选一个，求最大价值</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i-1][j],dp[i-1,j-v[i][k]]+w[i][k])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><p>因此本质上还是01背包问题，我们将其转化为01背包，只不过多一层循环k依次迭代更新每一组的各件物品；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i][k]]+w[i][k]);</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5CHenry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210718095737656.png" alt="image-20210718095737656" /></p><p>关于题目的文字表述：</p><p><img src="C:%5CUsers%5CHenry%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210719135356535.png" alt="image-20210719135356535" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动态规划&quot;&gt;&lt;/a&gt; 动态规划&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id=&quot;背包模型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背包模型&quot;&gt;&lt;/a&gt; 背包模</summary>
      
    
    
    
    
    <category term="OI" scheme="https://wangyuhang-cmd.github.io/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>ST_RMQ</title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/08/ST-RMQ/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/08/ST-RMQ/</id>
    <published>2021-08-08T11:37:00.000Z</published>
    <updated>2021-08-08T11:42:27.990Z</updated>
    
    <content type="html"><![CDATA[<p>ST算法，处理RMQ区间最大值问题</p><p>ST预处理函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST_prework</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ST[i][<span class="number">0</span>]=arr[i];</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;t;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//由公式ST[i,j]=max(ST[i,j-1],ST[i+2^(j-1),j-1]</span></span><br><span class="line">        ST[i][j]=<span class="built_in">max</span>(ST[i][j<span class="number">-1</span>],ST[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ST_query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="built_in">log</span>(r-l+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(ST[l][k],ST[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ST算法，处理RMQ区间最大值问题&lt;/p&gt;
&lt;p&gt;ST预处理函数&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    
    <category term="OI" scheme="https://wangyuhang-cmd.github.io/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/08/STL/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/08/STL/</id>
    <published>2021-08-08T11:36:46.303Z</published>
    <updated>2021-08-08T11:42:00.422Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*STL笔记部分*/</span></span><br><span class="line"></span><br><span class="line">vector动态数组&#123;</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">claer</span>()...</span><br><span class="line">    <span class="comment">//系统位某一程序申请空间的所需时间与空间大小无关，与次数有关,因此需要倍增vector</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">3</span>)</span></span>; <span class="comment">//定义长度位10的vector每个数初始化为3</span></span><br><span class="line">    遍历方式：</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//迭代器遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:a) ... <span class="comment">//C++11特性</span></span><br><span class="line">    支持比较运算，按字典序比较大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&#123;</span><br><span class="line">    可以存储一个二元组pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;</span><br><span class="line">    p.first,p.second分别取第一个第二的元素</span><br><span class="line">    支持比较运算，按照字典序，以first为第一关键字，second为第二关键字</span><br><span class="line">    p=<span class="built_in">make_pair</span>(a,b) <span class="comment">//pair的构造</span></span><br><span class="line">    p=&#123;a,b&#125; <span class="comment">//c++11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string字符串&#123;</span><br><span class="line">    <span class="built_in">c_str</span>() <span class="comment">//返回string对应的字符数组的头指针</span></span><br><span class="line">    如果使用<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue 队列</span><br><span class="line"><span class="built_in">priority_queue</span>(优先队列/堆)&#123;</span><br><span class="line">    <span class="comment">//默认是大根堆</span></span><br><span class="line">    改成小根堆：</span><br><span class="line">        <span class="number">1.</span>插入负数</span><br><span class="line">        <span class="number">2.</span>priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="built_in">push</span>(); 插入</span><br><span class="line">    <span class="built_in">top</span>();</span><br><span class="line">    <span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">stack 栈</span><br><span class="line"><span class="built_in">deque</span>(双端队列,效率低)</span><br><span class="line">set,multiset&#123;</span><br><span class="line">    <span class="comment">//set里面不能有重复元素，multiset里面可以有重复元素</span></span><br><span class="line">    set/multiset:</span><br><span class="line">        <span class="built_in">insert</span>()</span><br><span class="line">        <span class="built_in">find</span>() <span class="comment">//不存在返回end迭代器</span></span><br><span class="line">        count返回某个数的个数</span><br><span class="line">        <span class="built_in">erase</span>()</span><br><span class="line">            (<span class="number">1</span>)<span class="built_in">erase</span>(x),删除所有这个数</span><br><span class="line">            (<span class="number">2</span>)<span class="built_in">erase</span>(it)，删除此迭代器</span><br><span class="line">        <span class="built_in">lower_bound</span>(x)返回大于等于x的最小的数</span><br><span class="line">        <span class="built_in">upper_bound</span>(x)返回大于x的最小的数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map,multimap 基于平衡二叉树(红黑树)实现，动态维护有序序列&#123;</span><br><span class="line">    <span class="built_in">insert</span>();   插入的是<span class="function">pair</span></span><br><span class="line"><span class="function">    <span class="title">erase</span><span class="params">()</span></span>;    输入的参数是pair或者迭代器</span><br><span class="line">    [] 映射，<span class="built_in">O</span>(logn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(哈希表)&#123;</span><br><span class="line">unordered_set</span><br><span class="line">unordered_map</span><br><span class="line">unordered_multiset</span><br><span class="line">unordered_multima</span><br><span class="line">    <span class="comment">//增删改查是O(1);</span></span><br><span class="line">    <span class="comment">//不支持upper_bound和lower_bound</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bitset</span>(位存储，状态压缩)&#123;</span><br><span class="line">    <span class="keyword">bool</span> a[<span class="number">1024</span>]=<span class="number">1024B</span>,bitset&lt;<span class="number">1024</span>&gt;=<span class="number">128B</span></span><br><span class="line">    <span class="built_in">count</span>() 返回有多少个<span class="number">1</span></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  是否全为<span class="number">0</span></span><br><span class="line">    <span class="built_in">set</span>()  把多有位置变成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k,v) 把第k位变成v</span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 等价于把第k位取反</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初涉图论</title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/08/%E5%88%9D%E6%B6%89%E5%9B%BE%E8%AE%BA/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/08/%E5%88%9D%E6%B6%89%E5%9B%BE%E8%AE%BA/</id>
    <published>2021-08-08T10:08:27.000Z</published>
    <updated>2021-08-10T03:22:36.562Z</updated>
    
    <content type="html"><![CDATA[<h4 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h4><p>DFS实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(<span class="keyword">int</span> u)&#123;</span><br><span class="line">    <span class="keyword">for</span> u 的所有邻点</span><br><span class="line">        seq&lt;-u</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//seq是拓扑排序的逆序</span></span><br></pre></td></tr></table></figure><p> BFS</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*对于一个序列x...y,对于图中的每一条有向边，x都出现y的前面</span></span><br><span class="line"><span class="comment">即所有边都是从前指向后的</span></span><br><span class="line"><span class="comment">只要有环，必然无拓扑序列</span></span><br><span class="line"><span class="comment">有向无环图必然存在拓扑序列</span></span><br><span class="line"><span class="comment">入度为0的点都可以排在前面</span></span><br><span class="line"><span class="comment">做法：</span></span><br><span class="line"><span class="comment">1.把所有入度为0的点入队</span></span><br><span class="line"><span class="comment">2.bfs()</span></span><br><span class="line"><span class="comment">while(!Q&gt;empty())&#123;</span></span><br><span class="line"><span class="comment">    t.push(队头)</span></span><br><span class="line"><span class="comment">    队头-&gt;t</span></span><br><span class="line"><span class="comment">    枚举t的所有出边&#123;</span></span><br><span class="line"><span class="comment">        删除t-&gt;j,d[j]--;</span></span><br><span class="line"><span class="comment">        if(d[j]==0) j入队</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t=Q.<span class="built_in">front</span>();ds.<span class="built_in">push_back</span>(Q.<span class="built_in">front</span>());</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            d[j]--;</span><br><span class="line">            <span class="keyword">if</span>(d[j]==<span class="number">0</span>) Q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz=ds.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> sz&gt;=n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路算法知识结构图"><a href="#最短路算法知识结构图" class="headerlink" title="最短路算法知识结构图"></a>最短路算法知识结构图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最短路问题&#123;</span></span><br><span class="line"><span class="comment">    单源最短路&#123;</span></span><br><span class="line"><span class="comment">        1.所有边权都是正数&#123;</span></span><br><span class="line"><span class="comment">            1.朴素Dijkstra算法 O(n^2) 适用于稠密图</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            2.堆优化的Dijkstra O(mlog(n)) 适用于稀疏图</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        2.存在负权边&#123;</span></span><br><span class="line"><span class="comment">            1.Bellman-Ford O(nm)</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            2.SPFA 一般O(m)最坏O(nm)</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    多源汇最短路&#123;</span></span><br><span class="line"><span class="comment">Floyed算法        </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>稠密图：一般边数m=n^2</p><p>稀疏图：边数m=n</p><p>Dijkstra基于贪心算法</p><p>Floyed基于动态规划</p><p>Bellman-Ford基于离散数学中的知识</p><hr><h2 id="朴素版Dijkstra算法"><a href="#朴素版Dijkstra算法" class="headerlink" title="朴素版Dijkstra算法"></a>朴素版Dijkstra算法</h2><p>s={当前已经确定最短距离的点}</p><p>1.初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>,dis[otherwise]=+∞</span><br></pre></td></tr></table></figure><p>2.循环迭代(贪婪规则：更新当前还没有确定的点中距离最小的点）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i:<span class="number">0</span>~n)迭代循环n次</span><br><span class="line">不在s中的距离最近的点-&gt;t</span><br><span class="line">t-&gt;s <span class="comment">//将t加到s集合内</span></span><br><span class="line">用t来更新其他点的距离(<span class="built_in">check</span>(dis[x]&gt;dis[t])</span><br></pre></td></tr></table></figure><p>3.可确定每一个点到起点的最短距离了    </p><p>存法：使用邻接矩阵(因为是稠密图)</p><h4 id="朴素Dijstra解法："><a href="#朴素Dijstra解法：" class="headerlink" title="朴素Dijstra解法："></a>朴素Dijstra解法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN],g[MAXN][MAXN];</span><br><span class="line"><span class="keyword">bool</span> st[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span>||dis[t]&gt;dis[j]))</span><br><span class="line">                t=j;</span><br><span class="line"><span class="keyword">if</span>(t==n) <span class="keyword">break</span>;</span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            dis[j]=<span class="built_in">min</span>(dis[j],dis[t]+g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断一下是否是孤立点</span></span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如果是稀疏图的话，对照上面的朴素Dijkstra，我们可以在这一步：</p><p>2.循环迭代(贪婪规则：更新当前还没有确定的点中距离最小的点）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i:<span class="number">0</span>~n)迭代循环n次</span><br><span class="line">不在s中的距离最近的点-&gt;<span class="function">t  ****************<span class="title">O</span><span class="params">(n^<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">t-&gt;s <span class="comment">//将t加到s集合内</span></span></span><br><span class="line"><span class="function">用t来更新其他点的距离<span class="params">(check(dis[x]&gt;dis[t]) ***O(mlogn)</span></span></span><br></pre></td></tr></table></figure><p><strong><em>此处使用堆来进行优化，直接借助于STL中的prority_queue或者手写堆（Python中的set）</em></strong></p><p>bfs的迭代方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先将(<span class="number">0</span>,<span class="number">1</span>)放入优先队列 <span class="comment">//必须是小根堆</span></span><br><span class="line"><span class="number">2.</span><span class="keyword">while</span>！empty:取堆顶元素并弹出,如果此点已经被更新过了则继续迭代。</span><br><span class="line">否则用当前点来更新其他点(遍历邻接表)，记住，一定要将此点放入st[]数组来被标记</span><br><span class="line">如果当前点距离大于从最近元素过来的距离，则更新dis[]并把j点放入优先队列；</span><br><span class="line"><span class="number">3.</span>最后结束的时候需要判断是否是孤立点，即是否为连通图</span><br></pre></td></tr></table></figure><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用邻接表存储稀疏图</span></span><br><span class="line"><span class="keyword">int</span> n,m,idx;</span><br><span class="line"><span class="keyword">int</span> h[MAXN],e[MAXN],ne[MAXN],w[MAXN];<span class="comment">//h[]存储每个邻接表上的头结点；ne[]存的是每个节点的下一个节点，即next；w存储权重</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> st[MAXN];</span><br><span class="line"><span class="comment">//pair的first存的是距离，second存的是编号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx]=b,w[idx]=c;</span><br><span class="line">    ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; heap; <span class="comment">//存储一个小根堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> u = heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ver = u.second,distance = u.first;  <span class="comment">//ver存储点的序号，distance存储距离</span></span><br><span class="line">        <span class="keyword">if</span>(st[ver]) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[ver]=<span class="literal">true</span>; <span class="comment">//这nm千万别忘了啊</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;distance+w[i])&#123;</span><br><span class="line">                dis[j]=distance+w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Bellman-Ford算法-O-n-m"><a href="#Bellman-Ford算法-O-n-m" class="headerlink" title="Bellman_Ford算法 O(n*m)"></a>Bellman_Ford算法 O(n*m)</h3><p>任意存边方式都可，建议结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(n次)&#123;</span><br><span class="line">备份（防止用更新过的点更新其他点）</span><br><span class="line"><span class="keyword">for</span> 所有从a走到b的边，权重是w&#123;</span><br><span class="line">dis[b]=<span class="built_in">min</span>(dis[b],dis[a]+w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环完，所有边都满足三角不等式dis[b]&lt;=dis[a]+w;迭代k次表示经过不超过k条边的最短路的距离。如果第n次迭代仍然有边更新，根据抽屉原理，说明有负环。因此，Bellman-Ford算法可以用来找负环。</p><p>注意：如果有负权回路，最短路不一定存在</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 510</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,w;  </span><br><span class="line">&#125; edge[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAXN],backup[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//n次迭代,又名松弛操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup,dis,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a=edge[j].a,b=edge[j].b,w=edge[j].w;</span><br><span class="line">            dis[b]=<span class="built_in">min</span>(dis[b],backup[a]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edge[i].a=a,edge[i].b=b,edge[i].w=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><pre><code>0.用邻接表存储1.队头入队，更新st数组2.BFS思路while队列不空,t&lt;-q.front(),p.pop()3.遍历t的邻接表，更新dis[]数组，即t每一出点的最小距离；4.在每一出点判断，如果不在队列里，则加入队列；5.最后迭代完之后的判断</code></pre><p>​    </p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 160010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用邻接表存储稀疏图</span></span><br><span class="line"><span class="keyword">int</span> n,m,idx;</span><br><span class="line"><span class="keyword">int</span> h[MAXN],e[MAXN],ne[MAXN],w[MAXN];<span class="comment">//h[]存储每个邻接表上的头结点；ne[]存的是每个节点的下一个节点，即next；w存储权重</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> st[MAXN];</span><br><span class="line"><span class="comment">//pair的first存的是距离，second存的是编号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    Q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求负环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="comment">//memset(dis,0x3f,sizeof(dis));    </span></span><br><span class="line">    <span class="comment">//dis[1]=0;    </span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;        </span><br><span class="line">        st[i]=<span class="literal">true</span>;        </span><br><span class="line">        Q.<span class="built_in">push</span>(i);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">while</span>(Q.<span class="built_in">size</span>())&#123;        </span><br><span class="line">        <span class="keyword">int</span> t=Q.<span class="built_in">front</span>();Q.<span class="built_in">pop</span>();        </span><br><span class="line">        st[t]=<span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;            </span><br><span class="line">            <span class="keyword">int</span> j=e[i];            </span><br><span class="line">                                      </span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;                </span><br><span class="line">                dis[j]=dis[t]+w[i];                </span><br><span class="line">                cnt[j] = cnt[t]+<span class="number">1</span>;                </span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;n) <span class="keyword">return</span> <span class="literal">true</span>;                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;                    </span><br><span class="line">                    Q.<span class="built_in">push</span>(j);                    </span><br><span class="line">                    st[j]=<span class="literal">true</span>;                </span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Floyd算法-O-n-3"><a href="#Floyd算法-O-n-3" class="headerlink" title="Floyd算法 O(n^3)"></a>Floyd算法 O(n^3)</h3><p>1.邻接矩阵 d [ i , j ] 存图中每个点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>~n)</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>~n)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>~n)</span><br><span class="line">            d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j];</span><br></pre></td></tr></table></figure><p>d[k,i,j]表示从i点经过1~k中间点到达j的最短距离<br>因此基于动态规划的状态转移方程为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[k,i,j]=<span class="built_in">min</span>(d[k,i,j],d[k<span class="number">-1</span>,i,k]+d[k<span class="number">-1</span>,k,j])</span><br></pre></td></tr></table></figure><p>从i到j只经过k-1这些点，再从k到j只经过1~k-1这些点，加在一起就是从i~j经过k个点,而k-1可以压缩掉，故状态转移方程为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j];</span><br></pre></td></tr></table></figure><h4 id="Floyd算法用来解决的问题："><a href="#Floyd算法用来解决的问题：" class="headerlink" title="Floyd算法用来解决的问题："></a>Floyd算法用来解决的问题：</h4><p>​    1.最短路问题</p><p>​    2.传递闭包</p><p>​    3.找最小环</p><p>​    4.恰好经过k条边的最短路径</p><h5 id="传递闭包"><a href="#传递闭包" class="headerlink" title="传递闭包"></a>传递闭包</h5><p>在有向图中，能间接到的点也连一条有向边</p><p>邻接矩阵的表示方式：已知g(i,j),求d(i,j)</p><p>1.初始化 d(i,j)=g(i,j)</p><p>2.对d(i,j)做一遍Floyd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g</span>(i,j)=存在i-&gt;j?<span class="number">1</span>:<span class="number">0</span></span><br><span class="line">    <span class="comment">//Floyd</span></span><br><span class="line">    <span class="keyword">for</span> k:n</span><br><span class="line">        <span class="keyword">for</span> i:n</span><br><span class="line">            <span class="keyword">for</span> j:n</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">d</span>(i,k)==<span class="number">1</span>&amp;&amp;<span class="built_in">d</span>(k,j)==<span class="number">1</span>)                <span class="built_in">d</span>(i,j)=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>矛盾的判断方式：d(i,i)=1</p><p>能唯一确定的判断方式: i != j 必有 d(i,j) | d(j,i) == 1</p><p>顺序不唯一：处于中间阶段</p><h5 id="恰好经过k条边的最短路径之改进Floyd"><a href="#恰好经过k条边的最短路径之改进Floyd" class="headerlink" title="恰好经过k条边的最短路径之改进Floyd"></a>恰好经过k条边的最短路径之改进Floyd</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Floyd:  d[k,i,j]表示从i到j只经过<span class="number">1</span>-k的最短路径</span><br><span class="line">本思路： d[k,i,j]表示从i到j，恰好经过k条边的最短路径</span><br><span class="line">则状态转移方程为：</span><br><span class="line">    d[a+b,i,j]=<span class="built_in">min</span>(d[a,i,k]+d[b,k,j]) k=<span class="number">1</span>-n</span><br></pre></td></tr></table></figure><p>k指的是第a个点，此算法可以处理有负环的情况</p><p>使用倍增的思想来拼接，用logn的复杂度逼近k</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;拓扑排序：&quot;&gt;&lt;a href=&quot;#拓扑排序：&quot; class=&quot;headerlink&quot; title=&quot;拓扑排序：&quot;&gt;&lt;/a&gt;拓扑排序：&lt;/h4&gt;&lt;p&gt;DFS实现&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    
    <category term="OI" scheme="https://wangyuhang-cmd.github.io/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>test_my_site</title>
    <link href="https://wangyuhang-cmd.github.io/2021/08/08/test-my-site/"/>
    <id>https://wangyuhang-cmd.github.io/2021/08/08/test-my-site/</id>
    <published>2021-08-08T06:00:33.000Z</published>
    <updated>2021-08-08T11:42:51.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> Hello World!</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hello-world&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hello-world&quot;&gt;&lt;/a&gt; Hello World!&lt;/h1&gt;
</summary>
      
    
    
    
    
    <category term="OI" scheme="https://wangyuhang-cmd.github.io/tags/OI/"/>
    
  </entry>
  
</feed>
